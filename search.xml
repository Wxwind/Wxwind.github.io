<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PBR光照计算公式介绍</title>
      <link href="Physical-Based-Rendering-And-BRDF/"/>
      <url>Physical-Based-Rendering-And-BRDF/</url>
      
        <content type="html"><![CDATA[<p>参考视频：<br><a href="https://www.bilibili.com/video/BV1B54y1j7zE">图形 2.4 传统经验光照模型详解</a><br><a href="https://www.bilibili.com/video/BV1X7411F744?p=15">GAMES101-现代计算机图形学入门-闫令琪 P15</a><br>参考资料：<br><a href="https://learnopengl.com/PBR/Theory">PBR-learnopengl</a><br><a href="https://zhuanlan.zhihu.com/p/158025828">彻底看懂PBR/BRDF方程-知乎</a><br><a href="https://blog.csdn.net/a6333230/article/details/82968484">辐射强度、辐亮度、辐照度——一文搞定</a><br><a href="https://blog.csdn.net/a6333230/article/details/90036993">辐射照度、辐射强度、光照度、发光强度（差异以及如何相互转换）（易懂讲解）</a><br><a href="https://zhuanlan.zhihu.com/p/53086060">【基于物理的渲染（PBR）白皮书】（一） 开篇：PBR核心知识体系总结与概览</a><br><a href="https://blog.csdn.net/Terie/article/details/109460237">【实时渲染】菲涅尔反射率</a><br><a href="https://blog.csdn.net/leonwei/article/details/104044122/">PBR以及在Disney和UE渲染模型中的使用</a><br><a href="https://seblagarde.wordpress.com/2011/08/17/hello-world/">Adopting a physically based shading model这篇文章提供了大量的论文参考</a><br><a href="https://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf">Physically Based Shading at Disney</a><br><a href="https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf">Real Shading in Unreal Engine 4</a></p><h2 id="1-能量守恒在光照模型中的作用"><a href="#1-能量守恒在光照模型中的作用" class="headerlink" title="1.能量守恒在光照模型中的作用"></a>1.能量守恒在光照模型中的作用</h2><p>PBR（基于物理的渲染）是对现实近似模拟的渲染技术，旨在物理上合理地模拟光照效果，因此效果往往比非pbr渲染要好<br>PBR模型前置理论基础：微表面理论，能量守恒，菲涅尔反射</p><h2 id="微表面理论"><a href="#微表面理论" class="headerlink" title="微表面理论"></a>微表面理论</h2><p>微表面理论认为任何平面都是由极小的“微平面组成”<br><img src="52feb62bb440459f92b2f7107081cc3c.png" width="80%"><br>在微观层面上没有任何表面是完全光滑的，但鉴于这些微表面足够小，我们无法在每个像素的基础上区分它们，我们用一个“粗糙度”参数来估计微表面的粗糙度。再根据微表面的粗糙度，我们可以计算出微平面法线m与向量h一样的微平面的比例（这个比例具体如何计算后文会解释），这个h（halfway vector）也是blinn-phong模型使用到的半角向量，h的计算方式如下图（l:表面指向光源方向 v:表面指向视线方向）<br><img src="/Physical-Based-Rendering-And-BRDF/04c8cb62fdc94e11a76ff335e5d7eab5.png" alt="在这里插入图片描述"><br>从下图中可以看到只有法线等于h的微平面才能使光线反射到视线上。因此只要知道出与向量h一样的微平面的比例，就可以知道有多少微平面对观察者观察到的颜色有贡献<br><img src="/Physical-Based-Rendering-And-BRDF/24f9247556af4fc0b7c3f990b7f6142b.png" alt="24f9247556af4fc0b7c3f990b7f6142b"></p><p>粗糙度越大镜面反射范围越大，更暗；越小反射范围越小，越亮<br><img src="fc91399c8b804277b0ba2d0df8ab8c2e.png" width="80%"><br>微平面理论近似的遵循能量守恒定律：出射光的能量不能大于入射光的能量。（从上图也能看出，高光范围小更亮，范围大更暗）所以<font color=#ff0000>遵循能量守恒定律是为了让场景看起来更符合物理，更真实</font></p><p>微平面理论说明光线在交界点处会在多个方向上产生反射和折射光。<br><img src="7c3497a233d447e4a5c520517123f1b2.png" width="60%"></p><h2 id="菲涅尔反射"><a href="#菲涅尔反射" class="headerlink" title="菲涅尔反射"></a>菲涅尔反射</h2><p>想象观察一个湖面，远看（入射角大）树的倒影（反射）很清晰，近看（入射角小）湖面下的鱼（折射）清晰。可见<font color=#ff0000>随着入射角增大（从近到远看），光的反射率单调上升，折射率单调下降</font>。更容易看到物体表面上其他物体的倒影而很难看到物体内部的情况</p><p><font color=#ff0000>菲涅尔公式则描述了一束光经过两个介质交界面分裂成反射光和折射光时，反射光与折射光占原光线的比例</font>。（图中可正可负的意思是正负号与如何定义光线的正方向有关）<br>值得注意的是，折射光进入介质内部后可能会再次发生反射和折射，这部分被称为“次表面散射”，这些光部分会被吸收，部分会再次离开物体表面散射出去，形成<strong>漫反射</strong>。着色器用次表面散射可以以牺牲性能为代价显著改善皮肤，蜡或大理石等材料的视觉效果<br><img src="56aa33836d6d4d7598bdd8d11813b22c.png" width="40%"><br><img src="5f0bc529c56a45e192d1f86e2d468cad.png" width="60%"><br>rs是反射光的垂直分量，rp是反射光的水平分量，ts是折射光的垂直分量，tp是折射光的水平分量</p><p>对于自然光，s波和p波的能量相等，因此自然光的反射率$$R_n=\frac{1}{2}(R_s^2+R_p^2)=\frac{1}{2}[\frac{sin^2(θ_1-θ_2)}{sin^2(θ_1+θ_2)}+\frac{tan^2(θ_1-θ_2)}{tan^2(θ_1+θ_2)}]$$<br>当光线入射角趋近于0°（垂直于介质表面）时，有（n为折射率）<br>$$\frac{tanθ_1}{tanθ_2}\approx\frac{sinθ_1}{sinθ_2}\approx\frac{θ_2}{θ_1}=n$$<br>此时$$R_n=\frac{1}{2}(R_s^2+R_p^2)=(\frac{n-1}{n+1})^2$$<br><font color=#ff0000>接近0°入射角时的菲涅尔反射率Rn（表示反射光占原光线的比例）被记作F0</font>我们可以用上式，根据折射率（也称IOR）计算F0<br>不同材质其F0不同（线性和sRGB指色彩空间）,如下图所示<br><img src="21ad478720114d52852c339ea4897f59.png" width="80%" ><br>下图展示了不同波长和不同入射角下玻璃，铜和铝的菲涅尔反射率<br><img src="/Physical-Based-Rendering-And-BRDF/354b9f516db349afbf4e65076475a5fd.png" alt="354b9f516db349afbf4e65076475a5fd"><br>结合以上两图我们可以发现金属和非金属的菲涅尔反射有很大差异：</p><h3 id="金属"><a href="#金属" class="headerlink" title="金属"></a>金属</h3><img src="c27e07451cce479eaf278940a8d50f0c.png" width="60%">·菲涅尔反射率会受到波长影响，需要引入复数来表示反射率，因此用Fresnel-Schlick近似(下文会介绍)时需要用rgb三个值（且这三个值不同，体现对不同光有不同的吸收率）表示·反射率大部分在0.5和1之间，说明金属吸收了大部分折射光，其颜色主要是由镜面反射决定的<h3 id="非金属（电介质）"><a href="#非金属（电介质）" class="headerlink" title="非金属（电介质）"></a>非金属（电介质）</h3><img src="2ee40cbb2b2e42f4b69314fbb41b9bfc.png" width="60%"><p>·菲涅尔反射率与波长无关，因此F0只用一个值（一般取0.04）就能表示<br>·反射率几乎接近0，说明非金属的颜色主要是由漫反射（也就是折射光引起的次表面散射）决定的<br>（注意这里的漫反射和镜面反射是从微观角度上考虑的，看光线是反射光还是次表面散射光来区分，而平时说的漫反射和镜面反射从宏观上观察物体是否光滑来区分）</p><img src="b672ebe899cf40608024f759b5de3986.png" width="60%"><p>也许有人就会产生疑惑：根据微平面理论，直接反射光方向是多种多样的，那为什么这部分光不算漫反射而算镜面反射呢？<br>1.漫反射和镜面反射本质上都是光线，我们平时说的漫反射和镜面反射是从宏观角度观察物体，看物体表面是否光滑（光线是否集中），也就是根据结果来决定光线是镜面反射还是漫反射；而在PRB模型中，从微观角度观察光线，看光线是直接反射，还是次表面散射，也就是根据光线的路径决定光线是镜面反射还是漫反射<br>2.结合实际代码来理解，我们在像素着色器中计算BRDF，这里一个像素可以看作一个微元（一个微元有许多微平面），且拥有唯一一个法线，这个法线就代表这所有微平面法线的平均值，也就是说大体上微平面的法线都是与微元的法线一致，因此直接反射光主要集中在对称方向，且集中程度与粗糙度有关（可以看到当粗糙度变大，镜面反射的结果实际上就是我们从宏观角度所说的“漫反射”），所以用镜面反射描述直接反射光是比较精确的</p><h2 id="反射比方程-渲染方程-reflectance-equation"><a href="#反射比方程-渲染方程-reflectance-equation" class="headerlink" title="反射比方程/渲染方程(reflectance equation)"></a>反射比方程/渲染方程(reflectance equation)</h2><p>该方程是目前模拟光的视觉效果的最佳模型，具体如下<br><img src="1e484b34b9984c308ff78eda93c3c522.png" width="80%"><br>该方程描述了一个极小的微元表面接受光照后发出的光的功率。让我们先来看看这些字母分别代表什么</p><p>p:辐射功率。<font color=#ff0000>指单位时间内辐射源所发射的总辐射能</font><br>单位 瓦</p><p>ω:<font color=#ff0000>ωi表示入射光线（l） ，ω0表示出射光线（v）</font>，注意等号右边要积分的微元指的是立体角</p><p>dω:立体角，是站在某一点的观察者测量到的物体大小的尺度<br>锥体的立体角大小定义为：以锥体的顶点为球心作球面，该锥体在球表面截取的面积与球半径平方之比，<br>单位 球面度（一整个球的球面度为4π）<br>计算方式见下图<br><img src="e4e8d5654fb5437ba8999e05f0fce479.png" width="80%" ><br>&nbsp;</p><p>L:辐射亮度(radiance)，简称辐亮度。<font color=#ff0000>指面辐射源在单位时间内通过垂直于给定方向的平面上单位面积、单位立体角上辐射出的能量</font>，即辐射源在单位投影面积上、单位立体角内的辐射通量<br>计算方式：L=ddΦ/(dAdΩ·cosθ)，θ为立体角(solid angle)与法线之间的夹角<br>单位 瓦/(球面度·米^2)<br>辐射亮度表示面辐射源上某点在一定方向上的辐射强弱的物理量<br><img src="441cf184cf99497a88cfb8c46bfb62d8.png" width="40%"><br>&nbsp;</p><p>Φ:辐射通量。<font color=#ff0000>指单位时间内通过某一截面的辐射能</font><br>单位 瓦(焦耳/秒)</p><p>E:辐射照度(Irradiance)，简称辐照度。<font color=#ff0000>指接收物体的单位表面积上接收到的辐射功率</font><br>单位 瓦/米^2<br>计算方式见下图<br><img src="c62ad93c32724ecfa2d2f23196120204.png" width="70%" ><br>&nbsp;</p><p>下图直观地展示了这些物理量的区别和联系<br><img src="38e2e5b4c1b74bf4a25578a410b12dd6.png" width="80%" ><br><img src="/Physical-Based-Rendering-And-BRDF/721bffbbf79b459d8fe94d86d15916df-16564339165111.png"><br>（注意这里的辐亮度计算中分母的dA已经是投影面积，与上面的微元计算公式L=ddΦ/(dAdΩ·cosθ)不同，后者的da是光源上的微元面积因此要乘cosθ，以将其转换到垂直于光线的平面，即与上图介绍辐射亮度的图中黄色平面平行)</p><p>了解了这些字母的含义之后我们再回看渲染方程<br><img src="1e484b34b9984c308ff78eda93c3c522.png" width="80%"><br>该方程本质上告诉我们，给定在物体（物体接受光照后发出光也能看作辐射源）上一点A和入射光的信息，就能计算出射光的辐亮度(特指被眼睛观察到的出射光的辐亮度)<br>·L0表示A点出射光的辐亮度<br>·fr表示出射光辐亮度和入射光辐照度的比例函数<br>fr有多种形式的函数可以模拟，大体分为如下几种<br>1.BRDF（双向反射分布函数）：仅处理受光面，且不考虑次表面散射（因为漫反射属于次表面散射，所以严格地讲只是简单地考虑次表面散射）。适合不透明材质。本文只介绍BRDF<br>2.BTDF（双向透射分布函数）：仅处理背光面，且不考虑次表面散射。<br>3.BSDF（双向散射【反射+透射】分布函数）：处理受光面和背光面，且不考虑次表面散射。适合透明度比较高的材质。<br>4.BSSRDF（双向散射表面反射率分布函数）：处理受光面和背光面，考虑次表面散射，适合半透明材质，云，玉石，牛奶等。</p><p>·ωi表示入射光线光线方向l），w0表示出射光线（特指视线方向v）<br>·Li表示A点入射光的辐亮度，与fr函数相乘，再乘上n·ωi即可得到出射光的辐亮度L0<br>·n·ωi指入射光线和法线之间的夹角的余弦值，用于将入射光的辐亮度Li转换为辐照度E<br>·∫Ω dωi则是入射光半球的积分（因为光不可能同时照亮微元的两个面，所以是半球而不是整个球，这里的光并没有指定光源的种类，只要是从微元的正半球照射进来的光线都要考虑），可以理解为对入射半球上所有的ωi进行累加<br>fr的推导见<a href="https://zhuanlan.zhihu.com/p/158025828">彻底看懂PBR/BRDF方程 2. BRDF到底是啥?</a><br>接下来讨论怎么具体表示BRDF（fr函数）<br>BRDF分为diffuse（漫反射）和specular（镜面反射）两项</p><h3 id="diffuse-BRDF（漫反射）"><a href="#diffuse-BRDF（漫反射）" class="headerlink" title="diffuse BRDF（漫反射）"></a>diffuse BRDF（漫反射）</h3><img src="4ceb6fec84904afa83575a9073b0418c.png" >漫反射的计算方法大体分为两种，基于经验（如Lambert（朗伯/兰伯特））和基于物理。<p>1.Lambert diffuse<br>Lambert diffuse适用于朗伯辐射体：辐射源各方向上的辐射亮度不变，辐射强度随观察方向与面源法线之间的夹角θ的变化遵守余弦规律。<br>表达式如下:</p><p>$$f_{lambert}=\frac{C_{diffuse}}{π}$$<br>（Cdiffuse是材质本身的颜色，也被称作albedo（反射率）/basecolor（基础色）/surfaceColor（表面颜色））<br>正向推导：<br><img src="e708030a4e334612a24a82d8f1a639b3.png" width="80%"><br>可能会有人感到疑惑：这个Lambertian好像和我们说的兰伯特漫反射（n·l）不一样，但是我们令fr=c/π代回到反射比方程中，可以发现积分后π就被抵消掉了，而且乘上后面的n·ωi正好就是传统的lambert漫反射光照模型。因此我们可以把分母看作一个为了满足能量守恒定律而引入的归一化因子</p><p>2.Disney diffuse<br><img src="53e1097f074f45c29cea9086ff261d70.png" width="80%"><br>FD90指的是法线和视线呈90°时的菲涅尔反射率</p><h3 id="specular-BRDF（镜面反射）"><a href="#specular-BRDF（镜面反射）" class="headerlink" title="specular BRDF（镜面反射）"></a>specular BRDF（镜面反射）</h3><img src="9b6e75e00a1241dd95b098c2e11ad447.png" ><p>目前业界广泛采用的基于微表面理论的<a href="https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf">Microfacet Cook-Torrance BRDF模型</a>，公式如下（l:表面指向光源方向，v:表面指向视线方向，h:半角向量（微平面法线），n:微元法线）：<br><img src="/Physical-Based-Rendering-And-BRDF/847af04c43d548558042e823267f6459.png" alt="在这里插入图片描述"></p><p>（推导见[彻底看懂PBR/BRDF方程-知乎 7.镜面反射的BRDF如何推导？]）(<a href="https://zhuanlan.zhihu.com/p/158025828">https://zhuanlan.zhihu.com/p/158025828</a>)</p><p>可以看到该公式由分子的三个符号和分母的一个归一化因子组成，其中分子的DFG各代表微平面表面特性的一个近似描述的函数</p><h4 id="D：Normal-distribution-function（NDF）法线分布函数"><a href="#D：Normal-distribution-function（NDF）法线分布函数" class="headerlink" title="D：Normal distribution function（NDF）法线分布函数"></a>D：Normal distribution function（NDF）法线分布函数</h4><p><font color=#ff0000>法线分布函数表示法线与半角向量方向相同的点微平面占微元的比例</font><br>目前常用的是Disney的Trowbridge-Reitz（各向同性的GGX）模型，其中α是控制参数，这里α通常表示roughness^2（由roughness粗糙度对α进行映射，当然令α=roughness也没问题，毕竟roughness是手动控制的参数）（粗糙度在0-1之间，越大越粗糙）<br><img src="/Physical-Based-Rendering-And-BRDF/f70dc27965824300988f3ff146483c47.png" alt="在这里插入图片描述"><br>GGX优点：1.成本低廉 2.更长的拖尾显得更自然<br><img src="/Physical-Based-Rendering-And-BRDF/e382d73be36244b086547563b2d1a126.png" alt="e382d73be36244b086547563b2d1a126"></p><p>其他NDF模型（m是微平面法线，这里指半角向量h）<br><img src="/Physical-Based-Rendering-And-BRDF/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd3NXaW5k,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><h4 id="F：Fresnel-equation-菲涅尔方程"><a href="#F：Fresnel-equation-菲涅尔方程" class="headerlink" title="F：Fresnel equation 菲涅尔方程"></a>F：Fresnel equation 菲涅尔方程</h4><p><font color=#ff0000>菲涅尔方程表示反射到视线方向上的光占入射光的比例</font>，菲涅尔方程是一个相当复杂的方程，一般我们用Fresnel-Schlick近似表达菲涅尔反射率F<br><img src="/Physical-Based-Rendering-And-BRDF/f3722f9bf4ff405e8b99e69fb2af53cf.png" alt="在这里插入图片描述"><br>其中h是半角向量（也就是微平面的法线），v是视线方向矢量,h·v也说明视线离半角向量越近，菲涅尔反射越强,F0是接近0°入射角时的菲涅尔反射率（上文介绍过如何求F0）<br>ue4在2013siggraph上给出了这个形式的略微优化版本<br><img src="/Physical-Based-Rendering-And-BRDF/02dd3f4f86ad416ab1a0318657caba5e.png" alt="lut"></p><h4 id="G：Geometry-function-几何函数（阴影遮罩函数）"><a href="#G：Geometry-function-几何函数（阴影遮罩函数）" class="headerlink" title="G：Geometry function 几何函数（阴影遮罩函数）"></a>G：Geometry function 几何函数（阴影遮罩函数）</h4><img src="f95b57890a0d493891cf4271f0d90e22.png" >之前讲微平面理论的时候提到过只有法线等于h的微平面才对brdf做出贡献,但是法线等于h的微平面中可能会有一部分发出的反射光被其他微平面给阻挡，而<font color=#ff0000>几何函数就是描述法线等于h且未被遮蔽的微平面占微元的百分比。</font><p>1.Schlick-GGX模型<br>Schlick-GGX模型是GGX和Schlick-Beckmann的的结合：<br><img src="/Physical-Based-Rendering-And-BRDF/2ac6047dc8fb487eaa12dbbd3811d89c.png" alt="在这里插入图片描述"><br>其中K是对α（注意α与roughness的转换可能因引擎而异，下图的α实际上就是指roughness）的重新映射，与场景使用直接照明还是IBL（基于图像的照明，后文介绍环境光时会介绍）有关，这里反射率方程用于描述直接光，取(α+1)^2/8<br><img src="/Physical-Based-Rendering-And-BRDF/a28e20ac93e148de8e0227c24c322ad6.png" alt="在这里插入图片描述"><br>考虑到视线方向的几何遮挡和光方向矢量的几何阴影，我们根据Smith方法来包含两者得到最终的G值（Gsub指的就是Gschlick-GGX）：<br><img src="/Physical-Based-Rendering-And-BRDF/fc375c8e485b41e98c01ed77a0895614.png" alt="在这里插入图片描述"><img src="a8fe12e19e144ce78d7d71f29258a78b.png" ><br>这个模型也是ue在<a href="https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf">siggraph2013 ue 第29幅图</a>也提到过<br><img src="/Physical-Based-Rendering-And-BRDF/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd3NXaW5k,size_20,color_FFFFFF,t_70,g_se,x_16-16564304843061.png" alt="在这里插入图片描述"></p><p>2.Cook-Torrance模型<br><img src="/Physical-Based-Rendering-And-BRDF/80ba5ff3106141ba8859ec4a8a3d3b5f.png" alt="在这里插入图片描述"><br>3.Implict<br><img src="/Physical-Based-Rendering-And-BRDF/cb87ba4f13294879b071cdb6391bb6c4.png" alt="在这里插入图片描述"><br>想了解更多的diffuse和specular模型计算方式可以参考这两篇<br><a href="https://zhuanlan.zhihu.com/p/34473064">UE4中的基于物理的着色（一）</a><br><a href="https://blog.csdn.net/qq_35312463/article/details/108123270">镜面反射BRDF模型(Specular BRDF)及实现效果</a></p><h3 id="将漫反射与镜面反射合并"><a href="#将漫反射与镜面反射合并" class="headerlink" title="将漫反射与镜面反射合并"></a>将漫反射与镜面反射合并</h3><p>Cook-torrance模型提供了一种方案（据learnopengl所述）<br><img src="/Physical-Based-Rendering-And-BRDF/6e3e4a649dac4b4e8b6295698e0ea534.png" alt="在这里插入图片描述"><br><img src="/Physical-Based-Rendering-And-BRDF/d574b3a678f24b688c471d8e1c14ca0a.png" alt="在这里插入图片描述"></p><p>其中 ωi表示入射光向量(l)，ω0表示出射光向量(v)，kd是漫反射系数，ks是镜面反射系数（菲涅尔反射率），kd=1-ks（考虑到能量守恒。kd和ks表示入射光照射到物体表面微元后分配给漫反射和镜面反射的比例）<br>考虑到F实际隐含了Ks（F表示镜面反射光占入射光的比例，所以F=Ks），因此代入的过程中Ks应该删去，实际公式如下：<br><img src="/Physical-Based-Rendering-And-BRDF/bad4d7d18adf4c5195b81dd982f9c627.png" alt="在这里插入图片描述"><br>·对于电介质，kd=1（理论上应该是取1-F），F0一般取（0.04，0.04，0.04）就能代表大部分电介质的特性。<br>·对于导体/金属，我们引入了一个metalness（金属度）可控参数来对F0进行插值：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <strong>F0 = mix((0.04,0.04,0.04), albedo, metalness)</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <strong>kd=(1-ks)*(1-metalness)</strong><br>（可以看到metalness=0时F0=0.04（等价于电介质），metalness=1的时候则采用金属自身的反射率（F0）且没有漫反射）<br>(考虑到金属自由电子对光的吸收，因此ks+kd不一定等于1)<br><img src="/Physical-Based-Rendering-And-BRDF/a8e8a0741fd847cb87f21f00131acfe8.png" alt="在这里插入图片描述"></p><p>总结：直接光照就是上面的反射率公式，对于物体表面上的一个微元。给定微元法线正向的半球上所有的入射光的功率，我们可以得到物体在接收入射光后最终在视线方向上发出的光的功率。<br>在实际代码编写中，如果用反射率方程计算直接光照，环境光照另外单独计算，我们可以使用如下等价公式来简化只有直接光照的反射率方程：（中间的运算符表示对两边的矩阵或向量中的每个一 一对应的元素直接相乘，Clight指光源颜色）<br><img src="/Physical-Based-Rendering-And-BRDF/47c63aa6653446d090c8dbff2b85ea18.png" alt="在这里插入图片描述"><br>解析：Clight光源颜色与波长相关，波长与能量成反比，在相同时间内，能量与功率成正比，所以这里的L0（V）可以看作最终物体表面微元的颜色<br>翻译如下:<br><img src="/Physical-Based-Rendering-And-BRDF/5bc91f3aa0ce42b587fdff2a5130e3f6.png" alt="在这里插入图片描述"><br>图中（镜面反射+漫反射）还要再乘上π（半球积分后得到），考虑到镜面反射不像漫反射那样考虑来自四面八方的光，只考虑光源发出的指向微元的光，所以不用乘上π，漫反射乘上π后分母约掉<br><img src="/Physical-Based-Rendering-And-BRDF/a3282d58a36141bf8a5580fa84aa9dfb.png" alt="在这里插入图片描述"></p><h2 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h2><p>除了直接光以外我们还需要环境光（来自环境其他物体的光，默认等同于间接光），在传统经验光照模型中我们用一个常数来代替，在PBR中我们用反射率方程更精确地描述环境光对物体的影响（环境光与直接光很大的区别是，直接光方向是确定的，而环境光方向是来自四面八方其他物体的反射光的）<br><img src="/Physical-Based-Rendering-And-BRDF/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd3NXaW5k,size_20,color_FFFFFF,t_70,g_se,x_16-16564304843062.png" alt="在这里插入图片描述"><br>先介绍环境光照的表示形式<br>我们需要一种方式来表示来自各个方向的环境光的辐亮度（假设各个方向的环境光照都是来自无穷远处的）<br>1.球谐函数：<a href="https://zhuanlan.zhihu.com/p/153352797">详细介绍</a><br>2.球形高斯：<a href="https://therealmjp.github.io/posts/sg-series-part-2-spherical-gaussians-101/">详细介绍</a>（中文翻译版本：<a href="https://zhuanlan.zhihu.com/p/343751063">SG Series Part 2: 球形高斯基础</a>）<br>我们可以用一张图片来记录这些球形函数，这种图片叫做环境贴图<br>1.经纬度贴图<br>2.球形贴图<br>3.立方体贴图<br>（<a href="https://zhuanlan.zhihu.com/p/144910975">更具体的介绍请参考这篇</a>）</p><p>了解环境光照的表示形式后我们再来看环境光影响物体的表达式</p><p>环境光的反射率方程与直接光照的一样<br><img src="/Physical-Based-Rendering-And-BRDF/fa826164d576492cb703013e5d329ebb.png" alt="在这里插入图片描述"><br>可以看到漫反射和镜面反射可以拆分，于是变成如下形式<br><img src="/Physical-Based-Rendering-And-BRDF/a354fb0b25a7444b8f005833e0fe8fd1.png" alt="在这里插入图片描述"><br>环境光的漫反射与镜面反射需要用到预计算的贴图来存储信息，因此也被称为IBL（基于图像的光照），接下来我们分别详细讨论。</p><h3 id="环境光-漫反射"><a href="#环境光-漫反射" class="headerlink" title="环境光-漫反射"></a>环境光-漫反射</h3><p>对于漫反射部分，将常数移到外面，得到如下形式：<br><img src="/Physical-Based-Rendering-And-BRDF/4a209b53e9da4aeaac762ca9ff39ddeb.png" alt="在这里插入图片描述"><br>在直接照明-漫反射中，因为入射光线是确切知道方向的，所以很容易求出射光方向的辐亮度L0。但是环境光-漫反射中，对于每一个微元而言，来自周围环境的入射光不是唯一的。每个入射光方向wi都可能会有辐射，所以求解积分很复杂，这也给我们提出了两个要求：<br>1.需要一个方法来检索任何wi方向的环境光辐射度<br>2.求解积分必须实时快速<br>下面重点介绍一种解决方案–立方体贴图<br><strong>·1.立方体贴图（cube mapping）</strong><br>立方体贴图是事先预计算来自各个方向入射光的辐亮度Li，并存储到一张立方体贴图中（一个纹素对应一个出射光方向ω0）。<br>预计算方式：<br>对于每一个出射光ω0，我们构建一个正向的半球，在其中离散的取大量不同方向的入射光ωi并采样，然后求平均，得到的结果作为出射光ω0的辐照度，将出射光方向作为索引，结果以颜色值的形式存储在立方体贴图中<br><img src="/Physical-Based-Rendering-And-BRDF/a272d31dfc824c35abb3adb68fe08a28.png" alt="a272d31dfc824c35abb3adb68fe08a28"><br>因此这张立方体贴图也被称为辐照度环境贴图（irradiance map，也有把Irradiance Environment Mapping翻译成辉度环境映射的实在是有点难以理解）<br>（辐射方程还依赖于辐照度环境贴图的中心位置p，在场景中不同的位置得到的辐照度环境贴图不一样。渲染引擎通过在整个场景中放置反射探针（reflection probes）来解决此问题，每个反射探针计算其自身周围环境的辐照度贴图。这样，对于任意位置处的辐照度就可以通过离其最近的几个反射探头的辐照度的插值来得到。现在我们假设总是从辐照度环境贴图的中心位处采样，不考虑插值的事情）<br>下图是立方体环境贴图和其生成的立方体辐照度贴图的实例（尽管特别像高斯模糊但并不是直接模糊处理）<br><img src="/Physical-Based-Rendering-And-BRDF/8d2036f81e464dd6bb5fd3500889ae8d.png" alt="8d2036f81e464dd6bb5fd3500889ae8d"><br>具体如何生成？<br>参考：<br>我们把方程转换成如下形式：<br><img src="/Physical-Based-Rendering-And-BRDF/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd3NXaW5k,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center.jpeg" alt="在这里插入图片描述"><br><img src="/Physical-Based-Rendering-And-BRDF/f7e9d7ac82e84424b300870f15ea86cf.png" alt="在这里插入图片描述"><br>将积分转换为离散的累加和形式，n2对应不同的θ，n1对应不同的φ<br><img src="/Physical-Based-Rendering-And-BRDF/e878c52392d64f37a9007c1881ffab32.png" alt="e878c52392d64f37a9007c1881ffab32"><br>所以我们规定采样步长dθ和dφ就能对环境贴图进行采样，示例代码如下（来自<a href="https://blog.csdn.net/weixin_43803133/article/details/110385305">LearnOpenGL学习笔记—PBR：IBL</a>)：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">============================Vertex   Shader=======================</span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 normal;</span><br><span class="line">layout (location = <span class="number">2</span>) in vec2 texcoord;</span><br><span class="line">layout (location = <span class="number">3</span>) in vec3 color;</span><br><span class="line"></span><br><span class="line">out vec3 worldPos;</span><br><span class="line"></span><br><span class="line">uniform mat4 viewMatrix;</span><br><span class="line">uniform mat4 projectMatrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">worldPos = position;</span><br><span class="line">gl_Position = projectMatrix * viewMatrix * vec4(position,<span class="number">1.0f</span>);</span><br><span class="line">&#125;    </span><br><span class="line">============================Fragment Shader=======================</span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line">in vec3 worldPos;</span><br><span class="line"></span><br><span class="line">uniform samplerCube environmentMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> PI = <span class="number">3.14159265359</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 世界向量充当原点的切线曲面的法线，与WorldPos对齐。</span></span><br><span class="line"><span class="comment">// 给定此法线，计算环境的所有传入辐射。</span></span><br><span class="line">    vec3 N = normalize(worldPos);</span><br><span class="line"></span><br><span class="line">    vec3 irradiance = vec3(<span class="number">0.0</span>);   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算切线空间</span></span><br><span class="line">    vec3 up    = vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    vec3 right = normalize(cross(up, N));</span><br><span class="line">    up = normalize(cross(N, right));</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">float</span> sampleDelta = <span class="number">0.025</span>;</span><br><span class="line">    <span class="keyword">float</span> nrSamples = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">float</span> phi = <span class="number">0.0</span>; phi &lt; <span class="number">2.0</span> * PI; phi += sampleDelta)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">float</span> theta = <span class="number">0.0</span>; theta &lt; <span class="number">0.5</span> * PI; theta += sampleDelta)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 球面到笛卡尔（在切线空间中）</span></span><br><span class="line">            vec3 tangentSample = vec3(<span class="built_in">sin</span>(theta) * <span class="built_in">cos</span>(phi),  <span class="built_in">sin</span>(theta) * <span class="built_in">sin</span>(phi), <span class="built_in">cos</span>(theta));</span><br><span class="line">            <span class="comment">// 切线空间到世界空间</span></span><br><span class="line">            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N; </span><br><span class="line"></span><br><span class="line">            irradiance += texture(environmentMap, sampleVec).rgb * <span class="built_in">cos</span>(theta) * <span class="built_in">sin</span>(theta);</span><br><span class="line">            nrSamples++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    irradiance = PI * irradiance * (<span class="number">1.0</span> / <span class="keyword">float</span>(nrSamples));</span><br><span class="line">    </span><br><span class="line">    FragColor = vec4(irradiance, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个cube，将上述顶点着色器应用于该cube，则cube的6个面就是辐照度环境立方体贴图的6个面</p><p><strong>·2.球谐函数SH（球谐函数还没看懂，这里给出一些参考资料）</strong><br>参考：<a href="https://zhuanlan.zhihu.com/p/153352797">球谐光照——球谐函数</a><br><a href="https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-10-real-time-computation-dynamic">Chapter 10. Real-Time Computation of Dynamic Irradiance Environment Maps（GPU Gems2）</a></p><p><strong>·3.球形高斯SG</strong><br>参考：<a href="https://therealmjp.github.io/posts/sg-series-part-2-spherical-gaussians-101/">SG Series Part 2: Spherical Gaussians 101</a><br>球谐函数与球形高斯的原理与立方体贴图本质上差不多，是用不同的方法存储光照信息</p><h3 id="环境光-镜面反射"><a href="#环境光-镜面反射" class="headerlink" title="环境光-镜面反射"></a>环境光-镜面反射</h3><p>镜面反射部分如下：<br><img src="/Physical-Based-Rendering-And-BRDF/9f7ba1cd40434b30913e75fba208bea3.png" alt="在这里插入图片描述"><br>ks实际上不是一个常数，它取决于入射光方向ωi和视线方向v(ω0)（实际计算中因为F隐含了ks所以ks要删去）。同样因为对各个方向的ωi和v进行积分过于复杂所以无法实时计算。Epic对此提出了一种解决方案，在做出一定妥协的情况下，为了实时计算的目的对镜面反射部分进行预卷积，这种方法被称为分解求和近似（Split Sum Approximation）<br><strong>·分解求和近似</strong><br>该方面将镜面反射积分拆解成两个单独的积分。左边称为预过滤环境贴图（Pre-filtered environment map），右边则是BRDF（环境光光BRDF描述镜面反射的部分），下面分别介绍。<br><img src="/Physical-Based-Rendering-And-BRDF/5ddd17e5f704440fb429bd6c35087a21.png" alt="在这里插入图片描述"><br>等式的右边也可以表示成累加和的形式（也是我们之后用采样的方式求解积分的原理）<br><img src="/Physical-Based-Rendering-And-BRDF/6741002488d94d64b184f164aeb4739c.png" alt="在这里插入图片描述"><br>1.预过滤环境贴图（Pre-filtered environment map）<br><img src="/Physical-Based-Rendering-And-BRDF/aaf5892f40b444c9a612d25e27d1bb61.png" alt="aaf5892f40b444c9a612d25e27d1bb61"><br>预过滤环境贴图跟辐照图贴图类似，是预先卷积计算过的环境贴图，但预过滤环境贴图考虑到了粗糙度（roughness）的影响。为了体现不同的粗糙度级别，环境贴图会使用更为分散的入射光向量（也叫采样向量）计算卷积以产生更模糊的镜面反射，我们将不同粗糙度的计算结果存入mipmap的不同级别中，如下图所示<br><img src="/Physical-Based-Rendering-And-BRDF/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd3NXaW5k,size_20,color_FFFFFF,t_70,g_se,x_16-16564304843073.png" alt="在这里插入图片描述"></p><p><strong>生成预过滤环境贴图</strong>（重点：如何选择采样向量？）：<br>先引入几个概念（只是简单介绍，详细了解的话直接点击打开超链接）<br><a href="https://baike.baidu.com/item/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B/410082?fr=aladdin">大数定律（Law of Large Numbers）</a> ：简单理解为一个概率为P的事件做n次实验，实验次数越多，事件发生的频率越接近于概率P<br><a href="https://blog.csdn.net/hellocsz/article/details/94400402">蒙特卡洛积分（Monte Carlo）</a>：用一组满足分布律p(x)的若干随机数对被积函数在积分区间内采样。蒙特卡洛积分建立在大数定律的基础上，式子如下<br>（h(x)是被积函数，p(x)是被积函数理论上的概率密度函数（PDF），N是采样次数，设f(x)=h(x)/p(x),则蒙特卡洛积分的推导和公式如下）<br><img src="e7fca2c6b58b42e384f1b1d26da233c9.png" ><br>最后一步根据大数定律知，n越大，平均数越接近于期望</p><p>重要性采样（Importance Sampling）：蒙特卡洛积分选取采样点的一种方式。指选取的随机数（也叫采样点）集中在被积函数中对积分贡献较高的区域，而不是积分区间内均匀分布（直接采样）。这样选取可以减小方差，收敛速度快。下面给出两个参考链接：<br><a href="https://zhuanlan.zhihu.com/p/338103692">一文看懂蒙特卡洛采样方法</a><br><a href="https://www.jianshu.com/p/3d30070932a8">随机模拟-Monte Carlo积分及采样</a><br>下图给出重要性采样的公式。<br>h(x)是被积函数，p(x)是被积函数实际上的概率密度函数，N是采样次数，f(x)=h(x)/p(x)，q(x)是为了得出p(x)而引入的自定义的概率密度函数,根据下图可知，p(x)/q(x)为重要性权值<br><img src="/Physical-Based-Rendering-And-BRDF/cfa762104c934791b6e58bc86b0d2d72.png" alt="cfa762104c934791b6e58bc86b0d2d72"><br>根据蒙特卡洛积分，最后一行的表达式就是我们要求的最终积分值<br>————<br>了解上面这些概念之后，我们再来看下面这幅图<br><img src="/Physical-Based-Rendering-And-BRDF/3f6614734f7343728c84c49f3fe5a823.png" alt="在这里插入图片描述"><br>可以看到镜面反射的波瓣(lobe)尺寸随着粗糙度增加而变大。由于大多数光线都会集中在微平面法线向量h为中心的波瓣中，因此我们采样的光线（生成的样本向量）也应该满足这个规律（集中在波瓣中而不是像计算漫反射那样均匀取样本），这也是用到重要性采样的原因<br><img src="/Physical-Based-Rendering-And-BRDF/aaf5892f40b444c9a612d25e27d1bb61.png" alt="aaf5892f40b444c9a612d25e27d1bb61"><br>回看要积分的式子，下面给出ue中预过滤环境贴图的代码并给出解释（给定一个粗糙度roughness和镜面反射向量R求出该镜面反射方向上的辐亮度/颜色）<br><img src="/Physical-Based-Rendering-And-BRDF/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd3NXaW5k,size_20,color_FFFFFF,t_70,g_se,x_16-16564304843074.png" alt="在这里插入图片描述"><br>可以看到epic在此处令N=V=R，这是因为在卷积预过滤环境贴图的时候我们并不知道视线方向V。这意味着当我们从下图所示的角度观察时不会获得很好的镜面反射效果，但这通常被认为是合理的折衷方案<img src="/Physical-Based-Rendering-And-BRDF/f6d4000c40d54f569fd5b51466e49daf.png" alt="f6d4000c40d54f569fd5b51466e49daf">，因此fr中D项（NDF)=1</p><p>代码中Hammersley函数是生成随机数序列的一种方法，可以得到在[0,1]之间均匀分布的随机数序列（生成点在采样空间分布的均匀程度称作差异度Discrepancy，Hammersley属于低差异度序列），下面给出具体实现代码：(来自learn opengl)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">RadicalInverse_VdC</span><span class="params">(uint bits)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bits = (bits &lt;&lt; <span class="number">16u</span>) | (bits &gt;&gt; <span class="number">16u</span>);</span><br><span class="line">    bits = ((bits &amp; <span class="number">0x55555555</span>u) &lt;&lt; <span class="number">1u</span>) | ((bits &amp; <span class="number">0xAAAAAAAA</span>u) &gt;&gt; <span class="number">1u</span>);</span><br><span class="line">    bits = ((bits &amp; <span class="number">0x33333333</span>u) &lt;&lt; <span class="number">2u</span>) | ((bits &amp; <span class="number">0xCCCCCCCC</span>u) &gt;&gt; <span class="number">2u</span>);</span><br><span class="line">    bits = ((bits &amp; <span class="number">0x0F0F0F0F</span>u) &lt;&lt; <span class="number">4u</span>) | ((bits &amp; <span class="number">0xF0F0F0F0</span>u) &gt;&gt; <span class="number">4u</span>);</span><br><span class="line">    bits = ((bits &amp; <span class="number">0x00FF00FF</span>u) &lt;&lt; <span class="number">8u</span>) | ((bits &amp; <span class="number">0xFF00FF00</span>u) &gt;&gt; <span class="number">8u</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float</span>(bits) * <span class="number">2.3283064365386963e-10</span>; <span class="comment">// / 0x100000000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">vec2 <span class="title">Hammersley</span><span class="params">(uint i, uint N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vec2(<span class="keyword">float</span>(i)/<span class="keyword">float</span>(N), RadicalInverse_VdC(i));</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>重要性采样的函数如下，用于得到采样点且采样点分布受粗糙度影响（Phi:球面坐标系的φ，H：将球面坐标转换为笛卡尔坐标系）：<br><img src="/Physical-Based-Rendering-And-BRDF/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd3NXaW5k,size_20,color_FFFFFF,t_70,g_se,x_16-16564304843075.png" alt="在这里插入图片描述"></p><p>最后prefilteredColor除以总样本权重，其中对最终结果影响较小的样本（NdotL小）对最终结果的贡献就小。</p><p><strong>2.环境镜面反射BRDF</strong><br>环境镜面反射与环境漫反射求解思路相同，也是对大量入射光进行采样来预计算光照信息<br><img src="/Physical-Based-Rendering-And-BRDF/e408c65baae84c85b47a85ef18e282f4.png" alt="在这里插入图片描述"><br>其中<br><img src="/Physical-Based-Rendering-And-BRDF/1a0e040028a64b268265789660c42b1b.png" alt="在这里插入图片描述"></p><p>这个卷积要求我们同时考虑到入射角（n·ω0），表面粗糙度（影响fr中G和D项）和菲涅尔系数F0（与入射光矢量ω0）,对3个变量卷积实在复杂，但是我们可以对方程做点变换，先试着将F项移出方程<br><img src="/Physical-Based-Rendering-And-BRDF/fae95a1d023646e781aed0faee772cd0.png" alt="在这里插入图片描述"><br>将分母移到fr下<br><img src="/Physical-Based-Rendering-And-BRDF/7384f82b08324440afc1d02024d7cc2c.png" alt="在这里插入图片描述"><br>F项根据之前讲过的 Fresnel-Schlick计算<br><img src="/Physical-Based-Rendering-And-BRDF/f8f7e80bfbc84a019b9b4922399da8ad.png" alt="在这里插入图片描述"><br>为了式子看上去更简洁，我们用α表示（1-ω0·h）^5，之后再变形<br><img src="/Physical-Based-Rendering-And-BRDF/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd3NXaW5k,size_19,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>我们可以把最后一行式子拆成两项<br><img src="/Physical-Based-Rendering-And-BRDF/09b80add91d045dca3d8174d39d1c47a.png" alt="在这里插入图片描述"><br>重新把α替换回来<br><img src="/Physical-Based-Rendering-And-BRDF/af880e5c390a4480901a64e885c29919.png" alt="在这里插入图片描述"><br>我们把fr/F替换成一个新的fr，这个新的fr已经不含菲涅尔项F了；同时我们把F0常数移到积分外面，最终式子如下<br><img src="/Physical-Based-Rendering-And-BRDF/15ee749f99ae4f7999a87609f795bf46.png" alt="在这里插入图片描述"><br>这条函数形如F0*a+b,因此我们称左边积分为F0_Scale（缩放系数）,右边积分为F0_bias（偏移）。根据这条函数，我们就可以计算每一个像素（微元）的环境光镜面反射值，返回类型为float2/vec2，我们以颜色的形式（scale当作r，bias当作g）存储在一张贴图上，用roughness和 NdotV表示纹理索引/位置（这张贴图被称为2D LUT/2D查找纹理,也叫BRDF混合贴图（BRDF integration map））。示例图和代码实现如下（来自learn opengl，UE实现的方法是一样的）<br><img src="/Physical-Based-Rendering-And-BRDF/545f6bd3629347f0b766bf7e6fdccc2a.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">vec2 <span class="title">IntegrateBRDF</span><span class="params">(<span class="keyword">float</span> NdotV, <span class="keyword">float</span> roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 V;</span><br><span class="line">    V.x = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - NdotV*NdotV);</span><br><span class="line">    V.y = <span class="number">0.0</span>;</span><br><span class="line">    V.z = NdotV;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> A = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">float</span> B = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    vec3 N = vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint SAMPLE_COUNT = <span class="number">1024u</span>;</span><br><span class="line">    <span class="keyword">for</span>(uint i = <span class="number">0u</span>; i &lt; SAMPLE_COUNT; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec2 Xi = Hammersley(i, SAMPLE_COUNT);</span><br><span class="line">        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);</span><br><span class="line">        vec3 L  = normalize(<span class="number">2.0</span> * dot(V, H) * H - V);<span class="comment">//normalize(reflect(-V, H));</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> NdotL = max(L.z, <span class="number">0.0</span>);</span><br><span class="line">        <span class="keyword">float</span> NdotH = max(H.z, <span class="number">0.0</span>);</span><br><span class="line">        <span class="keyword">float</span> VdotH = max(dot(V, H), <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(NdotL &gt; <span class="number">0.0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> G = GeometrySmith(N, V, L, roughness);</span><br><span class="line">            <span class="keyword">float</span> G_Vis = (G * VdotH) / (NdotH * NdotV);</span><br><span class="line">            <span class="keyword">float</span> Fc = <span class="built_in">pow</span>(<span class="number">1.0</span> - VdotH, <span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">            A += (<span class="number">1.0</span> - Fc) * G_Vis;<span class="comment">//A是F0_Scale</span></span><br><span class="line">            B += Fc * G_Vis;<span class="comment">//B是F0_Bias</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A /= <span class="keyword">float</span>(SAMPLE_COUNT);</span><br><span class="line">    B /= <span class="keyword">float</span>(SAMPLE_COUNT);</span><br><span class="line">    <span class="keyword">return</span> vec2(A, B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GeometrySchlickGGX</span><span class="params">(<span class="keyword">float</span> NdotV, <span class="keyword">float</span> roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// G_ShclickGGX(N, V, k) = ( dot(N,V) ) / ( dot(N,V)*(1-k) + k )</span></span><br><span class="line">    <span class="keyword">float</span> a = roughness;</span><br><span class="line">    <span class="keyword">float</span> k = (a * a) / <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> nom   = NdotV;</span><br><span class="line">    <span class="keyword">float</span> denom = (NdotV * (<span class="number">1.0</span> - k) + k) + <span class="number">0.0001f</span>;<span class="comment">//防止分母为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nom / denom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GeometrySmith</span><span class="params">(vec3 N, vec3 V, vec3 L, <span class="keyword">float</span> roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> NdotV = max(dot(N, V), <span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">float</span> NdotL = max(dot(N, L), <span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">float</span> ggx2 = GeometrySchlickGGX(NdotV, roughness);</span><br><span class="line">    <span class="keyword">float</span> ggx1 = GeometrySchlickGGX(NdotL, roughness);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ggx1 * ggx2;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解释一下G_Vis的推导<br>G_Vis根据公式其实指的就是去除F项后的fr * NdotL，<br>∴ G_Vis=G·D·NdotL / (4·NdotL · NdotV)=G·D/ (4· NdotV)，<br>加上之前提到假设N=R=L所以D=1，<br>∴ G_Vis=G / (4 · NdotV)<br>根据重要性采样的公式，还需要乘上重要性权值（实际概率密度函数/自定义概率密度函数，这里自定义概率密度函数就是Hammersley法生成的[0,1]均匀分布序列，因此分母项为1可以省略，所以重要性权值就是实际概率密度函数，下文简称PDF）然后求平均，这里的PDF=4·VoH/NoH，与上式相乘结果与代码一致。(我是根据结果倒退的PDF，PDF等于这个值的时候就说的通了，这个PDF跟<a href="https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf">ue提到的PDF</a>正好互为倒数，我想了很久也没想通哪个是对的，还是说我推G_Vis的思路有问题，希望有大神能解答一下)</p><p>别忘了之前在介绍直接光G项的时候提到过，K值与粗糙度α的关系，因此这里用IBL的方式计算环境光的时候，k=（α^2）/2<br><img src="/Physical-Based-Rendering-And-BRDF/9f6a19b8b27744dfa04cf4ca7884c745.png" alt="在这里插入图片描述"><br>总结：在计算环境光BRDF项时，由于要对入射角（n·ω0，代码中的NdotV），表面粗糙度roughness（影响fr中G和D项）和菲涅尔系数F0(与入射光矢量ω0有关)三个变量积分（补充：尽管roughness与被积微元dω0没关系，但是每一个像素可能都有不同的粗糙度，因此在积分中也要考虑不同roughness的影响）过于复杂，因此采用预计算的方式，得出不同入射角、不同粗糙度下F0的值，将这些信息存储在一张贴图（称为LUT查找纹理）中。<br>在使用时，我们用NdotV和roughness对这张LUT采样，最终环境光BRDF的值为F0*LUT.r+LUR.g<br>————————<br>得到预过滤环境贴图与环境光BRDF项后，将两者相乘得到环境光-镜面反射值（这里的SpecularColor就是指F0），最终基于IBL的环境光-镜面反射的代码如下<br><img src="/Physical-Based-Rendering-And-BRDF/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd3NXaW5k,size_20,color_FFFFFF,t_70,g_se,x_16-16564304843086.png" alt="在这里插入图片描述"></p><p>将环境光漫反射与镜面反射相加得到完整的环境光，这里可以乘上一个系数AO来模拟物体之间挨的很近时环境光很弱产生的阴影（AO具体怎么计算本文不做过多叙述，可以参考网上其他资料，这里给出一个我觉觉得讲的挺好的：<a href="https://zhuanlan.zhihu.com/p/194198670">游戏中的全局光照(三) 环境光遮蔽/AO</a>）</p><p>最终将直接光与环境光相加得到完整的光照模型</p><h2 id="考虑次表面散射的BSSRDF（待补充）"><a href="#考虑次表面散射的BSSRDF（待补充）" class="headerlink" title="考虑次表面散射的BSSRDF（待补充）"></a>考虑次表面散射的BSSRDF（待补充）</h2><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/337384739">游戏中的次表面散射/Subsurface Scattering</a></p><p><strong>2.手写一个基于能量守恒的光照</strong><br>代码如下：（暂时只写了直接光部分）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/PBR&quot;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Albedo (<span class="string">&quot;Albedo&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        [Normal]_Normal (<span class="string">&quot;Normal&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span>&#123;&#125;</span><br><span class="line">        [NoScaleOffset]_AO (<span class="string">&quot;AO&quot;</span>, <span class="number">2</span>D)= <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        <span class="comment">//[NoScaleOffset]_Roughness (&quot;Roughness&quot;, 2D) = &quot;white&quot;&#123;&#125;</span></span><br><span class="line">        _Roughness(<span class="string">&quot;Roughnes&quot;</span>, range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">        _Bumpscale (<span class="string">&quot;Bumpscale&quot;</span>, range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">        _Metallic (<span class="string">&quot;Metallic&quot;</span>, range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">        _BaseColor (<span class="string">&quot;Basecolor&quot;</span>, Color)= (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">       </span><br><span class="line">        Pass&#123;</span><br><span class="line"></span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;UniversalForward&quot;</span>&#125; </span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">     </span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;</span></span></span><br><span class="line"></span><br><span class="line">            CBUFFER_START(UnityPerMaterial)</span><br><span class="line">            float4 _Albedo_ST;</span><br><span class="line">            float4 _Normal_ST;</span><br><span class="line">            <span class="keyword">float</span> _Bumpscale;</span><br><span class="line">            <span class="keyword">float</span> _Metallic;</span><br><span class="line">            float4 _BaseColor;</span><br><span class="line">            <span class="keyword">float</span> _Roughness;</span><br><span class="line">            CBUFFER_END</span><br><span class="line">            sampler2D _Albedo;        </span><br><span class="line">            sampler2D _Normal;</span><br><span class="line">            <span class="comment">//sampler2D _Roughness;</span></span><br><span class="line">            sampler2D _AO;</span><br><span class="line">            </span><br><span class="line">           <span class="function"><span class="keyword">float</span> <span class="title">DistributionGGX</span><span class="params">(<span class="keyword">float</span> NdotH,<span class="keyword">float</span> roughness)</span></span></span><br><span class="line"><span class="function">           </span>&#123;</span><br><span class="line">                <span class="keyword">float</span> a=roughness * roughness;</span><br><span class="line">                <span class="keyword">float</span> a2=a*a;<span class="comment">//分子</span></span><br><span class="line">                <span class="keyword">float</span> denom=NdotH*NdotH*(a2<span class="number">-1</span>)+<span class="number">1</span>;<span class="comment">//分母</span></span><br><span class="line">                denom=denom*denom*PI;</span><br><span class="line">                <span class="keyword">return</span> a2/denom;        </span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="function">float3 <span class="title">FresnelSchlick</span><span class="params">(float3 F0,<span class="keyword">float</span> VdotH)</span></span></span><br><span class="line"><span class="function">           </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> F0+(<span class="number">1</span>-F0)*<span class="built_in">pow</span>(<span class="number">1</span>-VdotH,<span class="number">5</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="function"><span class="keyword">float</span> <span class="title">GeometrySchlickGGX</span><span class="params">(<span class="keyword">float</span> NdotV, <span class="keyword">float</span> roughness)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">float</span> k=(roughness+<span class="number">1</span>)*(roughness+<span class="number">1</span>)/<span class="number">8</span>;</span><br><span class="line">                <span class="keyword">float</span> nom   = NdotV;</span><br><span class="line">                <span class="keyword">float</span> denom = NdotV * (<span class="number">1.0</span> - k) + k;</span><br><span class="line">                <span class="keyword">return</span> nom / denom;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           <span class="function"><span class="keyword">float</span> <span class="title">GeometrySmith</span><span class="params">(<span class="keyword">float</span> NdotV,<span class="keyword">float</span> NdotL,<span class="keyword">float</span> roughness)</span></span></span><br><span class="line"><span class="function">           </span>&#123;</span><br><span class="line">                <span class="keyword">float</span> ggx1 = GeometrySchlickGGX(NdotV, roughness);</span><br><span class="line">                <span class="keyword">float</span> ggx2 = GeometrySchlickGGX(NdotL, roughness);</span><br><span class="line">                <span class="keyword">return</span> ggx1 * ggx2;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 positionOS : POSITION;</span><br><span class="line">                float4 normalOS : NORMAL;</span><br><span class="line">                float4 tangentOS : TANGENT;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">                float4 positionCS : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                float4 normalWS : NORMAL;</span><br><span class="line">                float4 tangentWS : TANGENT;</span><br><span class="line">                float4 biotangentWS : TEXCOORD1;</span><br><span class="line">                float4 uv2 : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">        </span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(a2v v)</span></span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.positionCS = TransformObjectToHClip(v.positionOS.xyz);</span><br><span class="line">                float3 positionWS = TransformObjectToWorld(v.positionOS.xyz);</span><br><span class="line">                o.normalWS.xyz = normalize(TransformObjectToWorldNormal(v.normalOS.xyz));</span><br><span class="line">                o.tangentWS.xyz =normalize(TransformObjectToWorldDir(v.tangentOS.xyz));</span><br><span class="line">                o.biotangentWS.xyz =normalize(cross(o.normalWS.xyz,o.tangentWS.xyz) * v.tangentOS.w);</span><br><span class="line">                o.normalWS.w=positionWS.x;</span><br><span class="line">                o.tangentWS.w=positionWS.y;</span><br><span class="line">                o.biotangentWS.w=positionWS.z;</span><br><span class="line">                o.uv.xy = TRANSFORM_TEX(v.uv, _Albedo);</span><br><span class="line">                o.uv.zw = TRANSFORM_TEX(v.uv, _Normal);</span><br><span class="line">                o.uv2 = v.uv;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            <span class="function">half4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_Target </span>&#123;</span><br><span class="line">                <span class="keyword">float</span> roughness=_Roughness;</span><br><span class="line">                Light light = GetMainLight();</span><br><span class="line">                half3 Clight=light.color;</span><br><span class="line">                float3 L = normalize(light.direction);</span><br><span class="line">                float3 positionWS=float3(i.normalWS.w,i.tangentWS.w,i.biotangentWS.w);</span><br><span class="line">                float3 V=SafeNormalize(_WorldSpaceCameraPos.xyz - positionWS);</span><br><span class="line">                float3 H=SafeNormalize(L+V);</span><br><span class="line">                float3 Albedo = tex2D( _Albedo, i.uv.xy).xyz*_BaseColor.xyz;</span><br><span class="line">                <span class="comment">//float roughness=tex2D( _Roughness, i.uv2.xy).r;</span></span><br><span class="line">                float3 F0=lerp(float3(<span class="number">0.04</span>,<span class="number">0.04</span>,<span class="number">0.04</span>), Albedo, _Metallic);               </span><br><span class="line">                float3 AO = tex2D( _AO, i.uv2.xy).xyz;</span><br><span class="line">                <span class="comment">//计算法线（把法线从贴图的切线空间转换到世界空间下）                </span></span><br><span class="line">                float3x3 TtoW=&#123;i.tangentWS.xyz,i.biotangentWS.xyz,i.normalWS.xyz&#125;;  </span><br><span class="line">                TtoW=transpose(TtoW);                           </span><br><span class="line">                half3 NormalTS = UnpackNormalScale(tex2D( _Normal, i.uv.zw),_Bumpscale);</span><br><span class="line">                <span class="comment">// half3 NormalTS = UnpackNormal(tex2D( _Normal, i.uv.zw));</span></span><br><span class="line">                <span class="comment">// NormalTS.xy*=_Bumpscale;</span></span><br><span class="line">                NormalTS.z=<span class="built_in">sqrt</span>(<span class="number">1</span>-saturate(dot(NormalTS.xy,NormalTS.xy)));</span><br><span class="line">                float3 N=normalize(mul(TtoW,NormalTS));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//预先计算必要的点积</span></span><br><span class="line">                <span class="keyword">float</span> NdotH =max(dot(N,H),<span class="number">0.000001</span>);</span><br><span class="line">                <span class="keyword">float</span> VdotH=max(dot(V,H),<span class="number">0.000001</span>);</span><br><span class="line">                <span class="keyword">float</span> NdotV=max(dot(N,V),<span class="number">0.000001</span>);</span><br><span class="line">                <span class="keyword">float</span> NdotL=max(dot(N,L),<span class="number">0.000001</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                float3 diffuse=Albedo;</span><br><span class="line">                float3 diffuseColor=diffuse*Clight*NdotL;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">float</span> D=DistributionGGX(NdotH,roughness);</span><br><span class="line">                float3 F=FresnelSchlick(F0,VdotH);</span><br><span class="line">                <span class="keyword">float</span> G=GeometrySmith(NdotV,NdotL,roughness);</span><br><span class="line">                float3 specular=<span class="number">0.25</span>*D*F*G/(NdotV*NdotL);</span><br><span class="line">                float3 specularColor=specular*Clight*NdotL;</span><br><span class="line"></span><br><span class="line">                float3 kd=(<span class="number">1</span>-F)*(<span class="number">1</span>-_Metallic);</span><br><span class="line"></span><br><span class="line">                float3 ambient=<span class="number">0.03</span> * Albedo *AO;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> float4((kd*diffuseColor+specularColor),<span class="number">1.0f</span>);</span><br><span class="line">            &#125;           </span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Hidden/Universal Render Pipeline/FallbackError&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图（在线性空间下渲染，左边是官方的lit shader，右边是自己写的shader）：<br><img src="5301926269904d4e875812ac88acaa31.png" ><br>金属度=0.5，roughness从0到1：<br><img src="/Physical-Based-Rendering-And-BRDF/a46142a8942c42419d59e82a4edeeb07.gif" alt="在这里插入图片描述"><br>roughness=0.5，金属度从0到1：<br><img src="/Physical-Based-Rendering-And-BRDF/8eee1dc9ab9441929048bbe81aa909f2.gif" alt="在这里插入图片描述"><br>（注:上图测试的时候使用linear空间，albedo贴图忘记勾选srgb了，勾选上发现颜色会变暗（albedo经过一次gamma矫正）。与unity自带的pbr相比高光范围更小，更暗)</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PBR </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
